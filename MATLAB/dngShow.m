function dngShow(filename)
% dngShow()
% dngShow(filename)
%
% Reads and displays a DNG image generated by devCam. If no filename is
% supplied, prompts user to select a DNG file (or files).
%
% User may have to adjust function with Bayer array pattern for their device.
%
% Simple example of how to work with RAW image in MATLAB. For more
% information see https://users.soe.ucsc.edu/~rcsumner/rawguide/
%
% Rob Sumner,  March 2015

% Set the Bayer array pattern for your camera. For my Nexus 5, it's rggb.
% - - 'rggb','bggr','gbrg' or 'grbg' - -
bayer_type = 'rggb';

% Parse the input, one file or many?
if nargin==1
    % If a filename was actually passed
    process(filename)
else
    [fn fp] = uigetfile('*.dng','Multiselect','on');
    
    if ischar(fn)
        % A single YUV image was selected
        filename = [fp fn];
        process(filename);
    else
        % Multiple YUV images were selected
        for i=1:length(fn)
            filename = [fp fn{i}];
            process(filename)
        end
    end
end

% This actually does the processing of the parsed input
    function process(filename)
        
        % Define transformation matrix from sRGB space to XYZ space for later use
        srgb2xyz = [0.4124564 0.3575761 0.1804375;
            0.2126729 0.7151522 0.0721750;
            0.0193339 0.1191920 0.9503041];
        
        % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        % % % - - - - Reading DNG file from DNG Converter output - - - - % % %
        % MATLAB r2011a or later required.
        
        raw = dngRead(filename);
        meta_info = imfinfo(filename);
        height = size(raw,1);
        width = size(raw,2);
        
        % - - - Linearize - - -
        if isfield(meta_info,'LinearizationTable')
            ltab=meta_info.LinearizationTable;
            raw = ltab(raw+1);
        end
        black = meta_info.BlackLevel(1);
        saturation = meta_info.WhiteLevel;
        lin_bayer = (raw-black)/(saturation-black);
        lin_bayer = max(0,min(lin_bayer,1));
        clear raw
        
        % - - - White Balance - - -
        wb_multipliers = (meta_info.AsShotNeutral).^-1;
        wb_multipliers = wb_multipliers/wb_multipliers(2);
        mask = wbmask(height,width,wb_multipliers,bayer_type);
        balanced_bayer = lin_bayer .* mask;
        clear lin_bayer mask
        
        % - - - Color Correction Matrix from DNG Info - - -
        temp = meta_info.ColorMatrix2;
        xyz2cam = reshape(temp,3,3)';
        
        
        
        % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        % % % - - - - - The rest of the processing chain - - - - -
        
        % - - - Demosaicing - - -
        temp = uint16(balanced_bayer/max(balanced_bayer(:))*2^16);
        lin_rgb = single(demosaic(temp,bayer_type))/65535;
        clear balanced_bayer temp
        
        % - - - Color Space Conversion - - -
        rgb2cam = xyz2cam * srgb2xyz;
        rgb2cam = rgb2cam ./ repmat(sum(rgb2cam,2),1,3);
        cam2rgb = rgb2cam^-1;
        
        lin_srgb = apply_cmatrix(lin_rgb,cam2rgb);
        lin_srgb = max(0,min(lin_srgb,1));
        clear lin_rgb
        
        % - - - Brightness and Gamma - - -
        grayim = rgb2gray(lin_srgb);
        grayscale = 0.25/mean(grayim(:));
        bright_srgb = min(1,lin_srgb*grayscale);
        clear lin_srgb grayim
        
        nl_srgb = bright_srgb.^(1/2.2);
        
        % - - - Display output - - -
        figure
        imshow(nl_srgb)
    end

end

function colormask = wbmask(m,n,wbmults,align)
% COLORMASK = wbmask(M,N,WBMULTS,ALIGN)
%
% Makes a white-balance multiplicative mask for an image of size m-by-n
% with RGB while balance multipliers WBMULTS = [R_scale G_scale B_scale].
% ALIGN is string indicating Bayer arrangement: 'rggb','gbrg','grbg','bggr'

colormask = wbmults(2)*ones(m,n); %Initialize to all green values
switch align
    case 'rggb'
        colormask(1:2:end,1:2:end) = wbmults(1);    %r
        colormask(2:2:end,2:2:end) = wbmults(3);    %b
    case 'bggr'
        colormask(2:2:end,2:2:end) = wbmults(1);    %r
        colormask(1:2:end,1:2:end) = wbmults(3);    %b
    case 'grbg'
        colormask(1:2:end,2:2:end) = wbmults(1);    %r
        colormask(1:2:end,2:2:end) = wbmults(3);    %b
    case 'gbrg'
        colormask(2:2:end,1:2:end) = wbmults(1);    %r
        colormask(1:2:end,2:2:end) = wbmults(3);    %b
end
end



function corrected = apply_cmatrix(im,cmatrix)
% CORRECTED = apply_cmatrix(IM,CMATRIX)
%
% Applies CMATRIX to RGB input IM. Finds the appropriate weighting of the
% old color planes to form the new color planes, equivalent to but much
% more efficient than applying a matrix transformation to each pixel.

if size(im,3)~=3
    error('Apply cmatrix to RGB image only.')
end

r = cmatrix(1,1)*im(:,:,1)+cmatrix(1,2)*im(:,:,2)+cmatrix(1,3)*im(:,:,3);
g = cmatrix(2,1)*im(:,:,1)+cmatrix(2,2)*im(:,:,2)+cmatrix(2,3)*im(:,:,3);
b = cmatrix(3,1)*im(:,:,1)+cmatrix(3,2)*im(:,:,2)+cmatrix(3,3)*im(:,:,3);

corrected = cat(3,r,g,b);
end